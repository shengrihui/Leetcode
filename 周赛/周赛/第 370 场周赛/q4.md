记`b[i] = nums[i] - i`，对` nums[i] - nums[j] >= i - j`进行移项得到`nums[i] - i >= nums[j] - j`，也就是`b[i] >= b[j]`。

所以题目要求就变成了在`b`数组中找一个非降子序列，使得子序列对应的`nums`中的元素和最大。

记`f[i]`为`nums`中**以`i`结尾的**平衡子序列的最大和，因此答案为`max(f)`，状态转移方程为 $f[i] = nums[i]+\underset{0<=j<i 且
b[j]<=b[i]}{\max} \max(f[j],0)$。

意思是，遍历`nums`到`nums[i]`时，求`f[i]`，就是要在`i`之前找一个满足`b[j]<=b[i]`的最大的`f[j]`
。因为是遍历过来的然后往前找，所以自动满足`j<=i`。如果`f[i]<0`，就取为`0`，表示只取`nums[i]`。

到这里都好理解，后面就听不懂了。

想像有一个数组`c`，`c[ x=b[i] ] = f[ x=b[i] ]`，含义是，在`c`数组的`x`位置上存`f[x]`的值（这看起来`c`好像就是`f`，对的，是这样的）。

那么，要找满足`b[j]<=b[i]`的最大`f[j]`这件事，也就成了在`c`的`[0,b[i]]`区间内找到最大值。在区间内查询，并更新，所以用线段树。

怎么创建`c`？就是`f`，也就是线段树要维护的区间。

遍历`nums`，得到每一个值对应的`b[i]`，然后在`f`的`[0,f[b[i])`中找到最大的，和`nums[i]`相加更新`f[i]`。

现在的问题就是`b[i]`会是负数以及它的范围会很大。方法是离散化：将`b`中的值按大小顺序映射到`[0,len(b)-1]`上去，用字典`d`
来存储，字典的键是`b[i]`，字典的值是离散化映射过去的值，也就是`f`的下标。

总的步骤是：

1. 创建`b`数组，其中`b[i]=nums[i]-i`；
2. 用字典`d`存储`b`离散化后的结果，从小到大遍历排序后的`b`，每一个值为键，每一个下标为值作为离散化映射后的结果，如果有相同键就自动更新为较大的下标值；
3. 创建线段树`seg`，初始/默认值设为`-inf`，维护的区间大小为`len(b)`，也就是`f`的大小啦；
4. 遍历`nums`
    1. 计算`fi = d[nums[i]-i]`，
    2. 在`f`的`[0,fi+1)`范围内查询最大值，
    3. 用最大值加上`nums[i]`的和与`0`的较大值更新`f[fi]`；
5. 返回结果。
