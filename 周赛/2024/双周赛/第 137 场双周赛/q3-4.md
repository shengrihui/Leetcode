这是我第二次打进前200，也是第一次打进前100，还是第一次打进前50，更是第一次打进前30（至少目前是29）！！！
所以我好慌张，感觉这方法就把第四题过了有些不太对劲……

将每个格子的值 $x$ 和坐标 $(i,j)$ 作为三元组 $(x,i,j)$ 放到 $a$ 里，倒序排序。

遍历 $a$ 中所有元素，取出第一个格子的信息 $(s,x,y)$ ，然后在后面取出第二个 $(b,xx,yy)$
，如果这两个在同一行或者同一列就跳过，直到不同行不用列的为止将其作为第二个格子，并将 $b$ 加到 $s$ 中。接着用同样的方法找第三个格子。

由于是倒序排序，

1. 一旦找到一个合适第三个格子，那么就不用考虑后面的了。
2. 找到的第一个格子的值的三倍如果比目前的最佳答案 $ans$ 要小，则可以直接将 $ans$ 返回了。
3. 第一个格子的值 $s$ 加上两倍的第二个格子的值不比 $ans$ 大，就可以退出继续寻找第二个格子的循环了。

```python
class Solution:
    def maximumValueSum(self, board: List[List[int]]) -> int:
        a = []
        for i, row in enumerate(board):
            for j, x in enumerate(row):
                a.append((x, i, j))
        a.sort(reverse=True)
        ans = -inf
        n = len(a)
        for i in range(n):
            s, x, y = a[i]
            if s * 3 <= ans:
                return ans
            for j in range(i + 1, n):
                b, xx, yy = a[j]
                if s + b * 2 <= ans:
                    break
                if xx == x or yy == y:
                    continue
                ns = s + b
                for k in range(j + 1, n):
                    c, xxx, yyy = a[k]
                    if xxx == xx or xxx == x or yyy == yy or yyy == y:
                        continue
                    ns += c
                    ans = max(ans, ns)
                    break
        return ans
```

