主要说一下怎么计算 $[1,num]$ 的价值。

因为加入 $0$ 不影响结果，所以从 $0$ 开始想，$[0,num]$ 第 $i$ 位二进制数的变化规律是：$2^{i-1}$ 个 $0$ ，$2^{i-1}$ 个 $1$ ，$2^{i-1}$ 个 $0$ ，$2^{i-1}$ 个 $1$ ……

那么 $[0,num]$ 第 $i$ 位二进制数的 $1$ 的个数由两部分组组成：

把 「$2^{i-1}$ 个 $0$ ，$2^{b-1}$ 个 $1$」 叫做 「一组」。

1. 完整的一组
   有 $num >> b$ 组，所以有 $(m >> b) * (1 << (b - 1))$ 个 $1$ ( $2$ 的多少次方，就是 $1$ 右移多少位）
2. 不完整的那部分
   如果第 $i$ 位是 $0$，那在经历完整一组后这一位上没有 $1$；当第 $i$位是 $1$ 的时候，这一位上 $1$ 的数量是后 $i-1$ 位的值加 $1$（要算上第 $i$ 位是 $1$ 后面全 $0$ 的情况）。

所以，计算 $[1,num]$ 的价值，便是遍历 $num$ 的数位，如果那一位是 $x$ 的倍数，就计算这一位上有多少个 $1$ 。

```python3
class Solution:
    def findMaximumNumber(self, k: int, x: int) -> int:

        def chedk(m: int) -> bool:
            s = 0
            for i in range(1, m.bit_length() + 1):
                if i % x == 0:
                    s += (m >> i) * (1 << (i - 1))
                    if (m >> (i - 1)) & 1:
                        s += m % (1 << (i - 1))+1
                    if s > k:
                        return False
            return True

        l, r = 1, 10**19
        while l <= r:
            mid = (l + r) // 2
            if chedk(mid):
                l = mid + 1
            else:
                r = mid - 1
        return r
```

