**æ–¹æ³•ä¸€ï¼šFloyd ç®—æ³•**

æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„ $f$ï¼Œå…¶ä¸­ $f[i][j]$ è¡¨ç¤ºèŠ‚ç‚¹ $i$ åˆ°èŠ‚ç‚¹ $j$ æ˜¯å¦å¯è¾¾ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éå†å…ˆä¿®è¯¾ç¨‹æ•°ç»„ $prerequisites$ï¼Œå¯¹äºå…¶ä¸­çš„æ¯ä¸€é¡¹ $[a, b]$ï¼Œæˆ‘ä»¬å°† $f[a][b]$ è®¾ä¸º $true$ã€‚

ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨ Floyd ç®—æ³•è®¡ç®—å‡ºæ‰€æœ‰èŠ‚ç‚¹å¯¹ä¹‹é—´çš„å¯è¾¾æ€§ã€‚

å…·ä½“åœ°ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸‰é‡å¾ªç¯ï¼Œé¦–å…ˆæšä¸¾ä¸­é—´ç‚¹ $k$ï¼Œæ¥ä¸‹æ¥æšä¸¾èµ·ç‚¹ $i$ï¼Œæœ€åæšä¸¾ç»ˆç‚¹ $j$ã€‚å¯¹äºæ¯ä¸€æ¬¡å¾ªç¯ï¼Œå¦‚æœèŠ‚ç‚¹ $i$ åˆ°èŠ‚ç‚¹ $k$ å¯è¾¾ï¼Œä¸”èŠ‚ç‚¹ $k$ åˆ°èŠ‚ç‚¹ $j$ å¯è¾¾ï¼Œé‚£ä¹ˆèŠ‚ç‚¹ $i$ åˆ°èŠ‚ç‚¹ $j$ ä¹Ÿæ˜¯å¯è¾¾çš„ï¼Œæˆ‘ä»¬å°† $f[i][j]$ è®¾ä¸º $true$ã€‚

åœ¨è®¡ç®—å®Œæ‰€æœ‰èŠ‚ç‚¹å¯¹ä¹‹é—´çš„å¯è¾¾æ€§ä¹‹åï¼Œå¯¹äºæ¯ä¸€ä¸ªæŸ¥è¯¢ $[a, b]$ï¼Œæˆ‘ä»¬ç›´æ¥è¿”å› $f[a][b]$ å³å¯ã€‚

* [sol1-Python3]

```python
class Solution:
    def checkIfPrerequisite(
        self, n: int, prerequisites: List[List[int]], queries: List[List[int]]
    ) -> List[bool]:
        f = [[False] * n for _ in range(n)]
        for a, b in prerequisites:
            f[a][b] = True
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if f[i][k] and f[k][j]:
                        f[i][j] = True
        return [f[a][b] for a, b in queries]
```

* [sol1-Java]

```java
class Solution {
    public List<Boolean> checkIfPrerequisite(int n, int[][] prerequisites, int[][] queries) {
        boolean[][] f = new boolean[n][n];
        for (var p : prerequisites) {
            f[p[0]][p[1]] = true;
        }
        for (int k = 0; k < n; ++k) {
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    f[i][j] |= f[i][k] && f[k][j];
                }
            }
        }
        List<Boolean> ans = new ArrayList<>();
        for (var q : queries) {
            ans.add(f[q[0]][q[1]]);
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    vector<bool> checkIfPrerequisite(int n, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
        bool f[n][n];
        memset(f, false, sizeof(f));
        for (auto& p : prerequisites) {
            f[p[0]][p[1]] = true;
        }
        for (int k = 0; k < n; ++k) {
            for (int i = 0; i < n; ++ i) {
                for (int j = 0; j < n; ++ j) {
                    f[i][j] |= (f[i][k] && f[k][j]);
                }
            }
        }
        vector<bool> ans;
        for (auto& q : queries) {
            ans.push_back(f[q[0]][q[1]]);
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func checkIfPrerequisite(n int, prerequisites [][]int, queries [][]int) (ans []bool) {
	f := make([][]bool, n)
	for i := range f {
		f[i] = make([]bool, n)
	}
	for _, p := range prerequisites {
		f[p[0]][p[1]] = true
	}
	for k := 0; k < n; k++ {
		for i := 0; i < n; i++ {
			for j := 0; j < n; j++ {
				f[i][j] = f[i][j] || (f[i][k] && f[k][j])
			}
		}
	}
	for _, q := range queries {
		ans = append(ans, f[q[0]][q[1]])
	}
	return
}
```

* [sol1-TypeScript]

```ts
function checkIfPrerequisite(n: number, prerequisites: number[][], queries: number[][]): boolean[] {
    const f = Array.from({ length: n }, () => Array(n).fill(false));
    prerequisites.forEach(([a, b]) => (f[a][b] = true));
    for (let k = 0; k < n; ++k) {
        for (let i = 0; i < n; ++i) {
            for (let j = 0; j < n; ++j) {
                f[i][j] ||= f[i][k] && f[k][j];
            }
        }
    }
    return queries.map(([a, b]) => f[a][b]);
}
```

æ—¶é—´å¤æ‚åº¦ $O(n^3)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n^2)$ã€‚å…¶ä¸­ $n$ ä¸ºèŠ‚ç‚¹æ•°ã€‚

----

**æ–¹æ³•äºŒï¼šæ‹“æ‰‘æ’åº**

ä¸æ–¹æ³•ä¸€ç±»ä¼¼ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„ $f$ï¼Œå…¶ä¸­ $f[i][j]$ è¡¨ç¤ºèŠ‚ç‚¹ $i$ åˆ°èŠ‚ç‚¹ $j$ æ˜¯å¦å¯è¾¾ã€‚å¦å¤–ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªé‚»æ¥è¡¨ $g$ï¼Œå…¶ä¸­ $g[i]$ è¡¨ç¤ºèŠ‚ç‚¹ $i$ çš„æ‰€æœ‰åç»§èŠ‚ç‚¹ï¼›åˆ›å»ºä¸€ä¸ªæ•°ç»„ $indeg$ï¼Œå…¶ä¸­ $indeg[i]$ è¡¨ç¤ºèŠ‚ç‚¹ $i$ çš„å…¥åº¦ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éå†å…ˆä¿®è¯¾ç¨‹æ•°ç»„ $prerequisites$ï¼Œå¯¹äºå…¶ä¸­çš„æ¯ä¸€é¡¹ $[a, b]$ï¼Œæˆ‘ä»¬æ›´æ–°é‚»æ¥è¡¨ $g$ å’Œå…¥åº¦æ•°ç»„ $indeg$ã€‚

ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨æ‹“æ‰‘æ’åºè®¡ç®—å‡ºæ‰€æœ‰èŠ‚ç‚¹å¯¹ä¹‹é—´çš„å¯è¾¾æ€§ã€‚

å®šä¹‰ä¸€ä¸ªé˜Ÿåˆ— $q$ï¼Œåˆå§‹æ—¶å°†æ‰€æœ‰å…¥åº¦ä¸º $0$ çš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ä¸­ã€‚éšåä¸æ–­è¿›è¡Œä»¥ä¸‹æ“ä½œï¼šå–å‡ºé˜Ÿé¦–èŠ‚ç‚¹ $i$ï¼Œç„¶åéå† $g[i]$ ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ $j$ï¼Œå°† $f[i][j]$ è®¾ä¸º $true$ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æšä¸¾èŠ‚ç‚¹ $h$ï¼Œå¦‚æœ $f[h][i]$ ä¸º $true$ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¹Ÿå°† $f[h][j]$ è®¾ä¸º $true$ã€‚åœ¨è¿™ä¹‹åï¼Œæˆ‘ä»¬å°† $j$ çš„å…¥åº¦å‡å°‘ $1$ã€‚å¦‚æœæ­¤æ—¶ $j$ çš„å…¥åº¦ä¸º $0$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°† $j$ åŠ å…¥é˜Ÿåˆ—ä¸­ã€‚

åœ¨è®¡ç®—å®Œæ‰€æœ‰èŠ‚ç‚¹å¯¹ä¹‹é—´çš„å¯è¾¾æ€§ä¹‹åï¼Œå¯¹äºæ¯ä¸€ä¸ªæŸ¥è¯¢ $[a, b]$ï¼Œæˆ‘ä»¬ç›´æ¥è¿”å› $f[a][b]$ å³å¯ã€‚

* [sol2-Python3]

```python
class Solution:
    def checkIfPrerequisite(
        self, n: int, prerequisites: List[List[int]], queries: List[List[int]]
    ) -> List[bool]:
        f = [[False] * n for _ in range(n)]
        g = [[] for _ in range(n)]
        indeg = [0] * n
        for a, b in prerequisites:
            g[a].append(b)
            indeg[b] += 1
        q = deque(i for i, x in enumerate(indeg) if x == 0)
        while q:
            i = q.popleft()
            for j in g[i]:
                f[i][j] = True
                for h in range(n):
                    f[h][j] = f[h][j] or f[h][i]
                indeg[j] -= 1
                if indeg[j] == 0:
                    q.append(j)
        return [f[a][b] for a, b in queries]
```

* [sol2-Java]

```java
class Solution {
    public List<Boolean> checkIfPrerequisite(int n, int[][] prerequisites, int[][] queries) {
        boolean[][] f = new boolean[n][n];
        List<Integer>[] g = new List[n];
        int[] indeg = new int[n];
        Arrays.setAll(g, i -> new ArrayList<>());
        for (var p : prerequisites) {
            g[p[0]].add(p[1]);
            ++indeg[p[1]];
        }
        Deque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < n; ++i) {
            if (indeg[i] == 0) {
                q.offer(i);
            }
        }
        while (!q.isEmpty()) {
            int i = q.poll();
            for (int j : g[i]) {
                f[i][j] = true;
                for (int h = 0; h < n; ++h) {
                    f[h][j] |= f[h][i];
                }
                if (--indeg[j] == 0) {
                    q.offer(j);
                }
            }
        }
        List<Boolean> ans = new ArrayList<>();
        for (var qry : queries) {
            ans.add(f[qry[0]][qry[1]]);
        }
        return ans;
    }
}
```

* [sol2-C++]

```cpp
class Solution {
public:
    vector<bool> checkIfPrerequisite(int n, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
        bool f[n][n];
        memset(f, false, sizeof(f));
        vector<int> g[n];
        vector<int> indeg(n);
        for (auto& p : prerequisites) {
            g[p[0]].push_back(p[1]);
            ++indeg[p[1]];
        }
        queue<int> q;
        for (int i = 0; i < n; ++i) {
            if (indeg[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int i = q.front();
            q.pop();
            for (int j : g[i]) {
                f[i][j] = true;
                for (int h = 0; h < n; ++h) {
                    f[h][j] |= f[h][i];
                }
                if (--indeg[j] == 0) {
                    q.push(j);
                }
            }
        }
        vector<bool> ans;
        for (auto& qry : queries) {
            ans.push_back(f[qry[0]][qry[1]]);
        }
        return ans;
    }
};
```

* [sol2-Go]

```go
func checkIfPrerequisite(n int, prerequisites [][]int, queries [][]int) (ans []bool) {
	f := make([][]bool, n)
	for i := range f {
		f[i] = make([]bool, n)
	}
	g := make([][]int, n)
	indeg := make([]int, n)
	for _, p := range prerequisites {
		a, b := p[0], p[1]
		g[a] = append(g[a], b)
		indeg[b]++
	}
	q := []int{}
	for i, x := range indeg {
		if x == 0 {
			q = append(q, i)
		}
	}
	for len(q) > 0 {
		i := q[0]
		q = q[1:]
		for _, j := range g[i] {
			f[i][j] = true
			for h := 0; h < n; h++ {
				f[h][j] = f[h][j] || f[h][i]
			}
			indeg[j]--
			if indeg[j] == 0 {
				q = append(q, j)
			}
		}
	}
	for _, q := range queries {
		ans = append(ans, f[q[0]][q[1]])
	}
	return
}
```

* [sol2-TypeScript]

```ts
function checkIfPrerequisite(n: number, prerequisites: number[][], queries: number[][]): boolean[] {
    const f = Array.from({ length: n }, () => Array(n).fill(false));
    const g: number[][] = Array.from({ length: n }, () => []);
    const indeg: number[] = Array(n).fill(0);
    for (const [a, b] of prerequisites) {
        g[a].push(b);
        ++indeg[b];
    }
    const q: number[] = [];
    for (let i = 0; i < n; ++i) {
        if (indeg[i] === 0) {
            q.push(i);
        }
    }
    while (q.length) {
        const i = q.shift()!;
        for (const j of g[i]) {
            f[i][j] = true;
            for (let h = 0; h < n; ++h) {
                f[h][j] ||= f[h][i];
            }
            if (--indeg[j] === 0) {
                q.push(j);
            }
        }
    }
    return queries.map(([a, b]) => f[a][b]);
}
```

æ—¶é—´å¤æ‚åº¦ $O(n^2)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n^2)$ã€‚å…¶ä¸­ $n$ ä¸ºèŠ‚ç‚¹æ•°ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
